%{
----------------------------------------------------------------------------

This file is part of the Sanworks Bpod repository
Copyright (C) 2017 Sanworks LLC, Stony Brook, New York, USA

----------------------------------------------------------------------------

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3.

This program is distributed  WITHOUT ANY WARRANTY and without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
%}
classdef BpodObject < handle
    properties
        MachineType % 1 = Bpod 0.5, 2 = Bpod 0.7+, 3 = Pocket State Machine
        FirmwareVersion % An integer specifying the firmware on the connected device
        SerialPort % ArCOM serial port object
        HW % Hardware description
        Modules % Connected UART serial module description
        ModuleUSB % Struct containing a field for each connected module, listing its paired USB port (i.e. ModuleUSB.ModuleName = 'COM3')
        Status % Struct with system status variables
        Path % Struct with paths to Bpod root folder and specific sub-folders
        Data % Struct storing all data collected in the current session. SaveBpodSessionData saves this to the current data file.
        StateMatrix % Struct of matrices describing current (running) state machine
        StateMatrixSent % StateMatrix sent to the state machine, for the next trial. At run, this replaces StateMatrix.
        HardwareState % Current state of I/O lines and serial codes
        StateMachineInfo % Struct with information about state machines (customized for connected hardware)
        GUIHandles % Struct with graphics handles
        GUIData % Struct with graphics data
        InputsEnabled % Struct storing input channels that are connected to something. This is modified from the settings menu UI.
        SyncConfig % Struct storing the sync channel and mode (modified from settings menu UI)
        PluginSerialPorts % Struct with serial port objects for plugins (modules)
        PluginFigureHandles % Struct with figure handles for plugins
        PluginObjects % Struct with plugin objects
        SystemSettings % Struct with miscellaneous system settings
        SoftCodeHandlerFunction % The path to an m-file that accepts a byte code from Bpod and executes a MATLAB function (play sound, etc.)
        ProtocolFigures % A struct to hold figures used by the current protocol, which are automatically closed when the user presses the "Stop" button
        ProtocolSettings % The settings struct selected by the user in the launch manager, when launching a protocol
        Emulator % A struct with the internal variables of the emulator (mirror of state machine workspace in Arduino)
        ManualOverrideFlag % Used in the emulator to indicate an override that needs to be handled
        VirtualManualOverrideBytes % Stores emulated event byte codes generated by manual override
        CalibrationTables % Struct for liquid, sound, etc.
        BlankStateMachine % Holds a blank state machine to use with AddState().
        ProtocolStartTime % The time when the current protocol was started.
        BonsaiSocket % An object containing a TCP/IP socket for communication with Bonsai
        EmulatorMode % 0 if actual device connected, 1 if emulator
        HostOS % Holds a string naming the host operating system (i.e. 'Microsoft Windows XP')
        Timers % A struct containing MATLAB timer objects
    end
    properties (Access = private)
        CurrentFirmware % Struct of current firmware versions for state machine + curated modules 
        SplashData % Splash screen frames
        LastHardwareState % Last known state of I/O lines and serial codes
        CycleMonitoring % 0 = off, 1 = on. Measures min and max actual hardware timer callback execution time
    end
    methods
        function obj = BpodObject %Constructor            
            % Add Bpod code to MATLAB path
            BpodPath = fileparts(which('Bpod'));
            addpath(genpath(fullfile(BpodPath, 'Assets')));
            addpath(genpath(fullfile(BpodPath, 'Examples', 'State Machines')));
            load SplashBGData;
            load SplashMessageData;
            if exist('rng','file') == 2
                rng('shuffle', 'twister'); % Seed the random number generator by CPU clock
            else
                rand('twister', sum(100*fliplr(clock))); % For older versions of MATLAB
            end
            
            % Check for font
            F = listfonts;
            if (sum(strcmp(F, 'OCRAStd')) == 0) && (sum(strcmp(F, 'OCR A Std')) == 0)
                disp('ALERT! Bpod needs to install a system font in order to continue.')
                input('Press enter to install the font...');
                FontInstalled = 0;
                try
                    if ispc
                        system(fullfile(BpodPath, 'Assets', 'Fonts', 'OCRASTD.otf'));
                        FontInstalled = 1;
                    elseif ismac
                        copyfile(fullfile(BpodPath, 'Assets', 'Fonts', 'OCRASTD.otf'), '/Library/Fonts');
                        FontInstalled = 1;
                    else
                        disp('Please install the font using the Ubuntu font viewer, and close the font viewer to continue.')
                        MatlabPath = getenv('LD_LIBRARY_PATH');
                        setenv('LD_LIBRARY_PATH',getenv('PATH'));
                        FontPath = fullfile(BpodPath, 'Assets', 'Fonts', 'OCRAStd.otf');
                        system(['gnome-font-viewer ' FontPath]);
                        setenv('LD_LIBRARY_PATH',MatlabPath);
                        FontInstalled = 1;
                    end
                catch
                    error('Bpod was unable to install the font. Please install it manually from /Bpod/Media/Fonts/OCRASTD, and restart MATLAB. If you are having trouble, try running "sudo apt dist-upgrade" from a terminal before launching font viewer.')
                end
                if FontInstalled
                    error('Font installed. Please restart MATLAB and run Bpod again.')
                end
            end
            % Setup
            obj.SplashData.BG = SplashBGData;
            obj.SplashData.Messages = SplashMessageData;
            obj.GUIHandles.SplashFig = figure('Position',[400 300 485 300],'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off');
            obj.BonsaiSocket.Connected = 0;
            obj.Status.BpodStartTime = now;
            obj.Status = struct;
            obj.Status.LastTimestamp = 0;
            obj.Status.CurrentStateCode = 0;
            obj.Status.LastStateCode = 0;
            obj.Status.CurrentStateName = '';
            obj.Status.LastStateName = '';
            obj.Status.LastEvent = 0;
            obj.Status.Live = 0;
            obj.Status.Pause = 0;
            obj.Status.InStateMatrix = 0;
            obj.Status.BeingUsed = 0;
            obj.Status.BpodStartTime = 0;
            obj.Status.CurrentProtocolName = '';
            obj.Status.CurrentSubjectName = '';
            obj.Status.SerialPortName = '';
            obj.Status.NewStateMachineSent = 0;
            obj.Path = struct;
            obj.Path.BpodRoot = BpodPath;
            obj.Path.ParentDir = fileparts(BpodPath);
            obj.Path.LocalDir = fullfile(obj.Path.ParentDir, 'Bpod Local');
            obj.Path.SettingsDir = fullfile(obj.Path.LocalDir, 'Settings');
            obj.Path.Settings = '';
            obj.Path.DataFolder = '';
            obj.Path.CurrentDataFile = '';
            obj.Path.CurrentProtocol= '';
            obj.Path.InputConfig = fullfile(obj.Path.SettingsDir, 'InputConfig.mat');
            obj.Path.SyncConfig = fullfile(obj.Path.SettingsDir, 'SyncConfig.mat');
            obj.Path.ModuleUSBConfig = fullfile(obj.Path.SettingsDir, 'ModuleUSBConfig.mat');
            obj.StateMachineInfo = struct;
            obj.StateMachineInfo.nEvents = 0; % Number of events the state machine can respond to
            obj.StateMachineInfo.EventNames = 0; % Cell array of strings with names for each event
            obj.StateMachineInfo.InputChannelNames = 0; % cell array of strings with names for input channels
            obj.StateMachineInfo.nOutputChannels = 0; % Number of output channels
            obj.StateMachineInfo.OutputChannelNames = 0; % Cell array of strings with output channel names
            obj.StateMachineInfo.MaxStates = 0; % Maximum number of states the attached Bpod can store
            if ~exist(obj.Path.LocalDir)
                mkdir(obj.Path.LocalDir);
            end
            if ~exist(obj.Path.SettingsDir)
                mkdir(obj.Path.SettingsDir);
            end
            addpath(genpath(obj.Path.SettingsDir));
            if exist('BpodSettings.mat') > 0
                load BpodSettings;
                obj.SystemSettings = BpodSettings;
            else
                obj.SystemSettings = struct;
            end
            obj.Path.ProtocolFolder = '';
            if isfield(obj.SystemSettings, 'ProtocolFolder')
                if exist(obj.SystemSettings.ProtocolFolder)
                    obj.Path.ProtocolFolder = obj.SystemSettings.ProtocolFolder;
                end
            end
            obj.Path.DataFolder = '';
            if isfield(obj.SystemSettings, 'DataFolder')
                if exist(obj.SystemSettings.DataFolder)
                    obj.Path.DataFolder = obj.SystemSettings.DataFolder;
                end
            end
            
            obj.HostOS = system_dependent('getos');
            CalFolder = fullfile(obj.Path.LocalDir,'Calibration Files');
            if ~exist(CalFolder)
                mkdir(CalFolder);
                copyfile(fullfile(obj.Path.BpodRoot, 'Examples', 'Example Calibration Files'), CalFolder);
                questdlg('Calibration folder created in /BpodLocal/. Replace example calibration files soon.', ...
                    'Calibration folder not found', ...
                    'Ok', 'Ok');
            end
            % Liquid
            try
                LiquidCalibrationFilePath = fullfile(obj.Path.LocalDir, 'Calibration Files', 'LiquidCalibration.mat');
                load(LiquidCalibrationFilePath);
                obj.CalibrationTables.LiquidCal = LiquidCal;
            catch
                obj.CalibrationTables.LiquidCal = [];
            end
            % Sound
            try
                SoundCalibrationFilePath = fullfile(obj.Path.LocalDir, 'Calibration Files', 'SoundCalibration.mat');
                load(SoundCalibrationFilePath);
                obj.CalibrationTables.SoundCal = SoundCal;
            catch
                obj.CalibrationTables.SoundCal = [];
            end
            % Load input channel settings
            if ~exist(obj.Path.InputConfig)
                copyfile(fullfile(obj.Path.BpodRoot, 'Examples', 'Example Settings Files', 'InputConfig.mat'), obj.Path.InputConfig);
            end
            load(obj.Path.InputConfig);
            obj.InputsEnabled = BpodInputConfig;
            % Load sync settings
            if ~exist(obj.Path.SyncConfig)
                copyfile(fullfile(obj.Path.BpodRoot, 'Examples', 'Example Settings Files', 'SyncConfig.mat'), obj.Path.SyncConfig);
            end
            load(obj.Path.SyncConfig);
            obj.SyncConfig = BpodSyncConfig;
            
            % Create module USB port config file (if not present)
            if ~exist(obj.Path.ModuleUSBConfig)
                copyfile(fullfile(obj.Path.BpodRoot, 'Examples', 'Example Settings Files', 'ModuleUSBConfig.mat'), obj.Path.ModuleUSBConfig);
            end
            
            % Load list of current firmware versions
            CF = CurrentFirmwareList; % Located in /Functions/Internal Functions/, returns list of current firmware
                                      % for state machine and modules
            obj.CurrentFirmware = CF;
            % Create timer objects
            obj.Timers = struct;
            obj.Timers.PortRelayTimer = timer('TimerFcn','UpdateSerialTerminals()', 'ExecutionMode', 'fixedRate', 'Period', 0.1);
            obj.BpodSplashScreen(1);
        end
        function obj = InitializeHardware(obj, portString, varargin)
            if strcmp(portString, 'AUTO')
                Ports = obj.FindUSBSerialPorts;
                Ports = [Ports.Arduino Ports.Teensy];
            else
                Ports = {portString};
            end
            nPorts = length(Ports);
            Found = 0;
            iPort = 1;
            if nargin > 2
                ForceJava = 1;
            else
                ForceJava = 0;
            end
            while (Found == 0) && (iPort <= nPorts)
                ThisPort = Ports{iPort};
                disp(['Trying port: ' ThisPort])
                Connected = 0;
                if ForceJava
                    try
                        obj.SerialPort = ArCOMObject_Bpod(ThisPort, 115200, 'Java');
                        Connected = 1;
                    catch
                    end
                else
                    try
                        obj.SerialPort = ArCOMObject_Bpod(ThisPort, 115200);
                        Connected = 1;
                    catch
                    end
                end
                if Connected
                    obj.SerialPort.write('6', 'uint8');
                    pause(.1)
                    if obj.SerialPort.bytesAvailable > 0
                        Reply = obj.SerialPort.read(1, 'uint8');
                        if Reply == '5'
                            Found = 1;
                            thisPortIndex = iPort;
                            obj.Status.SerialPortName = ThisPort;
                        else
                            obj.SerialPort.delete;
                        end
                    else
                        obj.SerialPort.delete;
                    end
                end
                iPort = iPort + 1;
            end
            if Found
                obj.EmulatorMode = 0;
            else
                error('Error: Could not find Bpod device.');
            end
            disp(['Bpod connected on port ' Ports{thisPortIndex}])
            if obj.SerialPort.UsePsychToolbox == 0
                disp('###########################################################################')
                disp('# NOTICE: Bpod is running without Psychtoolbox installed.                 #')
                disp('# PsychToolbox integration greatly improves USB transfer speed + latency. #')
                disp('# See http://psychtoolbox.org/download/ for installation instructions.    #')
                disp('###########################################################################')
            end
            obj.SystemSettings.LastCOMPort = Ports{thisPortIndex};
            obj.SaveSettings;
            obj.EmulatorMode = 0;
            obj.BpodSplashScreen(2);
        end
        function obj = Setup(obj)
            if obj.EmulatorMode == 1 % Set up as Bpod 0.7
                obj.StateMachineInfo.MaxStates = 256;
                obj.HW.n.MaxSerialEvents = 60;
                obj.HW.CyclePeriod = 100;
                obj.HW.CycleFrequency = 10000;
                obj.HW.n.GlobalTimers = 5;
                obj.HW.n.GlobalCounters  = 5;
                obj.HW.n.Conditions  = 5;
                obj.HW.n.Inputs = 16;
                obj.HW.Inputs = 'UUUXBBWWPPPPPPPP';
                obj.HW.n.Outputs = 18;
                obj.HW.Outputs = 'UUUXSBBWWWPPPPPPPPGGG';
                close(obj.GUIHandles.LaunchEmuFig);
                disp('Connection aborted. Bpod started in Emulator mode.')
                obj.FirmwareVersion = obj.CurrentFirmware.StateMachine;
                obj.MachineType = 2;
                nModules = sum(obj.HW.Outputs=='U');
                obj.Modules.Connected = zeros(1,nModules);
                obj.Modules.Name = cell(1,nModules);
                obj.Modules.nSerialEvents = ones(1,nModules)*(obj.HW.n.MaxSerialEvents/(nModules+1));
                obj.Modules.EventNames = cell(1,nModules);
                obj.Modules.RelayActive = zeros(1,nModules);
                obj.Modules.USBport = cell(1,nModules);
            else
                % Get firmware version
                obj.SerialPort.write('F', 'uint8');
                obj.FirmwareVersion = obj.SerialPort.read(1, 'uint16');
                obj.MachineType = obj.SerialPort.read(1, 'uint16');
                if obj.FirmwareVersion ~= obj.CurrentFirmware.StateMachine
                    obj.SerialPort.write('Z');
                    obj.SerialPort = []; % Trigger the ArCOM port's destructor function (closes and releases port)
                    if obj.FirmwareVersion < obj.CurrentFirmware.StateMachine
                        disp([char(13) 'ERROR: Old state machine firmware detected, v' num2str(obj.FirmwareVersion) '. ' char(13)...
                            'Please update the state machine firmware to v' num2str(obj.CurrentFirmware.StateMachine) ', restart MATLAB and try again.' char(13)...
                            'The latest firmware is <a href="matlab:web(''https://github.com/sanworks/Bpod_Gen2/tree/master/Firmware/Gen2/State%20Machine'',''-browser'')">here</a>.' char(13) ...
                            'Installation instructions are <a href="matlab:web(''https://sites.google.com/site/bpoddocumentation/firmware-update'',''-browser'')">here</a>.' char(13)]);
                        error('Old firmware detected. See instructions above.');
                    else
                        error('The firmware on the Bpod state machine is newer than your Bpod software for MATLAB. Please update your MATLAB software from the Bpod repository and try again.')
                    end
                end
                % Request hardware description
                obj.SerialPort.write('H', 'uint8');
                obj.HW.n = struct; % Stores total numbers of different types of channels (e.g. 5 BNC input channels)
                obj.StateMachineInfo.MaxStates = obj.SerialPort.read(1, 'uint16');
                obj.HW.CyclePeriod = double(obj.SerialPort.read(1, 'uint16'));
                obj.HW.CycleFrequency = 1000000/double(obj.HW.CyclePeriod);
                obj.HW.n.MaxSerialEvents = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.n.GlobalTimers = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.n.GlobalCounters  = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.n.Conditions  = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.n.Inputs = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.Inputs = char(obj.SerialPort.read(obj.HW.n.Inputs, 'uint8'));
                obj.HW.n.Outputs = double(obj.SerialPort.read(1, 'uint8'));
                obj.HW.Outputs = [char(obj.SerialPort.read(obj.HW.n.Outputs, 'uint8')) 'GGG']; % G = Global timer / counter
                % Enable ports
                if length(obj.InputsEnabled) ~= obj.HW.n.Inputs
                    obj.InputsEnabled = zeros(1,obj.HW.n.Inputs);
                    PortPos = find(obj.HW.Inputs == 'P');
                    if ~isempty(PortPos)
                        obj.InputsEnabled(PortPos(1:3)) = 1;
                    end
                    obj.InputsEnabled(obj.HW.Inputs == 'B') = 1;
                    if obj.MachineType > 1 % v0.7+ uses optoisolators on wire channels; OK to enable by default
                        obj.InputsEnabled(obj.HW.Inputs == 'W') = 1;
                    end
                end
                obj.SerialPort.write(['E' obj.InputsEnabled], 'uint8');
                Confirmed = obj.SerialPort.read(1, 'uint8');
                if Confirmed ~= 1
                    error('Could not enable ports');
                end
                % Set up Sync config
                obj.SerialPort.write(['K' obj.SyncConfig.Channel obj.SyncConfig.SignalType], 'uint8');
                Confirmed = obj.SerialPort.read(1, 'uint8');
                if Confirmed ~= 1
                    error('Could not set sync configuration');
                end
            end
            obj.HW.ChannelKey = 'D = digital B/W = BNC/Wire (digital), P = Port (digital in, PWM out), S = SPI, U = UART, X = USB';
            obj.HW.n.BNCOutputs = sum(obj.HW.Outputs == 'B');
            obj.HW.n.BNCInputs = sum(obj.HW.Inputs == 'B');
            obj.HW.n.WireOutputs = sum(obj.HW.Outputs == 'W');
            obj.HW.n.WireInputs = sum(obj.HW.Inputs == 'W');
            obj.HW.n.Ports = sum(obj.HW.Outputs == 'P');
            obj.HW.n.DigitalInputs = obj.HW.n.BNCInputs + obj.HW.n.WireInputs + obj.HW.n.Ports;
            obj.HW.n.UartSerialChannels = sum(obj.HW.Outputs == 'U');
            obj.HW.n.USBChannels = sum(obj.HW.Outputs == 'X');
            obj.HW.n.SerialChannels = obj.HW.n.USBChannels + obj.HW.n.UartSerialChannels;
            obj.HW.n.SoftCodes = 10;
            obj.HW.EventTypes = [repmat('S', 1, obj.HW.n.MaxSerialEvents) repmat('I', 1, obj.HW.n.DigitalInputs*2) repmat('T', 1, obj.HW.n.GlobalTimers*2 ) repmat('+', 1, obj.HW.n.GlobalCounters)  repmat('C', 1, obj.HW.n.Conditions) repmat('J', 1, obj.HW.n.SerialChannels) 'U'];
            obj.HW.EventKey = 'S = serial, I = i/o, T = global timer, + = global counter, C = condition, J = jump, U = state timer';
            obj.HW.IOEventStartposition = find(obj.HW.EventTypes == 'I', 1);
            obj.HW.GlobalTimerStartposition = find(obj.HW.EventTypes == 'T', 1);
            obj.HW.GlobalCounterStartposition = find(obj.HW.EventTypes == '+', 1);
            obj.HW.ConditionStartposition = find(obj.HW.EventTypes == 'C', 1);
            obj.HW.StateTimerPosition = find(obj.HW.EventTypes == 'U');
            obj.HW.Pos = struct; % Positions of different channel types in hardware description vectors
            obj.HardwareState.Key = 'D = digital B/W = BNC/Wire (digital), P = Port (digital in, PWM out), S = SPI, U = UART, X = USB';
            obj.HardwareState.InputState = zeros(1,obj.HW.n.Inputs);
            obj.HardwareState.InputType = obj.HW.Inputs;
            obj.HardwareState.OutputState = zeros(1,obj.HW.n.Outputs+3);
            obj.HardwareState.OutputType = obj.HW.Outputs;
            obj.HardwareState.OutputOverride = zeros(1,obj.HW.n.Outputs+3);
            obj.LastHardwareState = obj.HardwareState;
            % Find positions of input channel groups
            obj.HW.Pos.Input_BNC = find(obj.HW.Inputs == 'B', 1);
            obj.HW.Pos.Input_Wire = find(obj.HW.Inputs == 'W', 1);
            obj.HW.Pos.Input_Port = find(obj.HW.Inputs == 'P', 1);
            obj.HW.Pos.Input_USB = find(obj.HW.Inputs == 'X', 1);
            obj.LoadModules;
            obj.SetupStateMachine;
            obj.BpodSplashScreen(3);
            obj.BpodSplashScreen(4);
            if isfield(obj.SystemSettings, 'BonsaiAutoConnect')
                if obj.SystemSettings.BonsaiAutoConnect == 1
                    try
                        disp('Attempting to connect to Bonsai. Timeout in 10 seconds...')
                        BpodSocketServer('connect', 11235);
                        obj.BonsaiSocket.Connected = 1;
                        disp('Connected to Bonsai on port: 11235')
                    catch
                        BpodErrorSound;
                        disp('Warning: Auto-connect to Bonsai failed. Please connect manually.')
                    end
                end
            end
            obj.BpodSplashScreen(5);
            close(obj.GUIHandles.SplashFig);
        end
        function obj = LoadModules(obj)
            if obj.EmulatorMode == 0 && obj.Status.BeingUsed == 0
                nModules = sum(obj.HW.Outputs=='U');
                if isfield(obj.Modules, 'USBport')
                    USBPairing = obj.Modules.USBport;
                else
                    USBPairing = cell(1,nModules);
                end
                % Get info from modules
                obj.Modules.nModules = nModules;
                obj.Modules.RelayActive = zeros(1,nModules);
                obj.StopModuleRelay();
                obj.Modules.Connected = zeros(1,nModules);
                obj.Modules.Name = cell(1,nModules);
                obj.Modules.FirmwareVersion = zeros(1,nModules);
                obj.Modules.nSerialEvents = ones(1,nModules)*(floor(obj.HW.n.MaxSerialEvents/obj.HW.n.SerialChannels));
                obj.Modules.EventNames = cell(1,nModules);
                obj.Modules.USBport = USBPairing;
                obj.SerialPort.write('M', 'uint8');
                pause(.1);
                messageLength = obj.SerialPort.bytesAvailable;
                moduleEventsRequested = zeros(1,obj.HW.n.UartSerialChannels);
                if messageLength > 1
                    for i = 1:nModules
                        obj.Modules.Connected(i) = obj.SerialPort.read(1, 'uint8');
                        if obj.Modules.Connected(i) == 1
                            obj.Modules.FirmwareVersion(i) = obj.SerialPort.read(1, 'uint32');
                            nBytes = obj.SerialPort.read(1, 'uint8');
                            NameString = obj.SerialPort.read(nBytes, 'char');
                            SameModuleCount = 0;
                            for j = 1:nModules
                                if strcmp(obj.Modules.Name{j}(1:end-1), NameString)
                                    SameModuleCount = SameModuleCount + 1;
                                end
                            end
                            obj.Modules.Name{i} = [NameString num2str(SameModuleCount+1)];
                            moreInfoFollows = obj.SerialPort.read(1, 'uint8');
                            if moreInfoFollows
                                while moreInfoFollows
                                    paramType = obj.SerialPort.read(1, 'uint8');
                                    switch paramType
                                        case '#' % Number of events requested by module
                                            moduleEventsRequested(i) = obj.SerialPort.read(1, 'uint8');
                                        case 'E' % Strings to replace default event names (e.g. ModuleName1_1)
                                            nStrings = obj.SerialPort.read(1, 'uint8');
                                            obj.Modules.EventNames{i} = cell(1,nStrings);
                                            for j = 1:nStrings
                                                nCharInThisString = obj.SerialPort.read(1, 'uint8');
                                                obj.Modules.EventNames{i}{j} = obj.SerialPort.read(nCharInThisString, 'char');
                                            end
                                    end
                                    moreInfoFollows = obj.SerialPort.read(1, 'uint8');
                                end
                            end
                        end
                    end
                    nEventsRequested = sum(moduleEventsRequested)+obj.HW.n.SoftCodes;
                    if nEventsRequested > obj.HW.n.MaxSerialEvents
                        error(['Error: modules requested more serial events ' num2str(nEventsRequested) ' than the current state machine can support ' num2str(obj.HW.n.MaxSerialEvents) '. Please reconfigure modules.'])
                    end
                    for i = 1:nModules
                        if obj.Modules.Connected(i) == 1
                            if moduleEventsRequested(i) > obj.Modules.nSerialEvents(i)
                                nToReassign = moduleEventsRequested(i) - obj.Modules.nSerialEvents(i);
                                obj.Modules.nSerialEvents(i) = moduleEventsRequested(i); % Assign events
                            else
                                nToReassign = 0;
                            end
                            Pos = nModules;
                            while nToReassign > 0
                                if obj.Modules.nSerialEvents(Pos) > 0 && obj.Modules.Connected(Pos) == 0
                                    if obj.Modules.nSerialEvents(Pos) >= nToReassign
                                        obj.Modules.nSerialEvents(Pos) = obj.Modules.nSerialEvents(Pos) - nToReassign;
                                        nToReassign = 0;
                                    else
                                        nToReassign = nToReassign - obj.Modules.nSerialEvents(Pos);
                                        obj.Modules.nSerialEvents(Pos) = 0;
                                    end
                                end
                                Pos = Pos - 1;
                                if Pos == 0
                                    error(['Error: modules requested more serial events ' num2str(nEventsRequested) ' than the current state machine can support ' num2str(obj.HW.n.MaxSerialEvents) '. Please reconfigure modules.'])
                                end
                            end
                        end
                    end
                    obj.HW.n.SoftCodes = obj.HW.n.MaxSerialEvents-sum(obj.Modules.nSerialEvents);
                    obj.SerialPort.write(['%' obj.Modules.nSerialEvents obj.HW.n.SoftCodes], 'uint8');
                    Confirmed = obj.SerialPort.read(1, 'uint8');
                    if Confirmed ~= 1
                        error('Error: State machine did not confirm module event reallocation');
                    end
                    
                    % Load module USB port configuration
                    USBPorts = obj.FindUSBSerialPorts;
                    USBPorts = [USBPorts.Arduino USBPorts.Teensy USBPorts.Sparkfun USBPorts.COM];
                    USBPorts = USBPorts(logical(1-strcmp(USBPorts, obj.SerialPort.PortName)));

                    for i = 1:length(obj.Modules.Name)
                        USBPorts = USBPorts(logical(1-strcmp(USBPorts, obj.Modules.USBport{i})));
                    end
                    load(obj.Path.ModuleUSBConfig);
                    for i = 1:obj.Modules.nModules
                        ThisModuleName = obj.Modules.Name{i};
                        ThisPortName = ModuleUSBConfig.USBPorts{i};
                        ExpectedModuleName = ModuleUSBConfig.ModuleNames{i};
                        if ~isempty(ThisModuleName) && ~isempty(ThisPortName) % If an entry exists
                            if sum(strcmp(ThisPortName, USBPorts)) > 0 % If the USB port is detected
                                if isempty(obj.Modules.USBport{i}) % If the module is unpaired
                                    if strcmp(ThisModuleName, ExpectedModuleName)
                                        obj.Modules.USBport{i} = ThisPortName;
                                        obj.ModuleUSB.(ThisModuleName) = ThisPortName;
                                    end
                                end
                            end
                        end
                    end
                else
                    error('Error requesting module information: state machine did not return enough data.')
                end
                if isfield(obj.GUIHandles, 'MainFig') % GUI was already loaded. Update tabs and panels.
                    obj.SetupStateMachine;
                    obj.refreshGUIPanels;
                    obj.FixPushbuttons;
                    if isfield(obj.GUIHandles, 'SystemInfoFig')
                        if ishandle(obj.GUIHandles.SystemInfoFig) % If info figure is open
                            close(obj.GUIHandles.SystemInfoFig);
                            BpodSystemInfo;
                            figure(obj.GUIHandles.MainFig);
                        end
                    end
                end
                for i = 1:nModules % Check for incompatible module firmware
                    thisModuleName = obj.Modules.Name{i}(1:end-1);
                    thisModuleFirmware = obj.Modules.FirmwareVersion(i);
                    if ~isempty(thisModuleName)
                        if isfield(obj.CurrentFirmware, thisModuleName)
                            expectedFirmwareVersion = obj.CurrentFirmware.(thisModuleName);
                            if thisModuleFirmware < expectedFirmwareVersion
                                disp([char(13) 'ERROR: ' thisModuleName ' module with old firmware detected, v' num2str(thisModuleFirmware) '. ' char(13)...
                                    'Please update its firmware to v' num2str(expectedFirmwareVersion) ', restart Bpod and try again.' char(13)...
                                    'Firmware upgrade instructions are <a href="matlab:web(''https://sites.google.com/site/bpoddocumentation/firmware-update'',''-browser'')">here</a>.' char(13)]);
                                BpodErrorSound;
                                errordlg('Old module firmware detected. See instructions in the MATLAB command window.');
                            elseif thisModuleFirmware > expectedFirmwareVersion
                                Errormsg = ['The firmware on the ' thisModuleName ' module on serial port ' num2str(i) ' is newer than your Bpod software for MATLAB. ' char(13) 'Please update your MATLAB software from the Bpod repository and try again.'];
                                errordlg(Errormsg)
                                error(Errormsg);
                            end                            
                        end
                    end
                end
            end
        end
        function obj = SetupStateMachine(obj)
            % Set up event and output names
            EventNames = cell(1,sum(obj.Modules.nSerialEvents) + obj.HW.n.SoftCodes + obj.HW.n.DigitalInputs*2 + 16);
            InputChannelNames = cell(1,obj.HW.n.Inputs);
            Pos = 1;
            nUSB = 0;
            nBNCs = 0;
            nWires = 0;
            nPorts = 0;
            nChannels = 0;
            for i = 1:obj.HW.n.Inputs
                switch obj.HW.Inputs(i)
                    case 'U'
                        nChannels = nChannels + 1;
                        if obj.Modules.Connected(i)
                            InputChannelNames{nChannels} = obj.Modules.Name{i};
                        else
                            InputChannelNames{nChannels} = ['Serial' num2str(i)];
                        end
                        for j = 1:obj.Modules.nSerialEvents(i)
                            Assigned = 0;
                            if ~isempty(obj.Modules.EventNames{i})
                                if j <= length(obj.Modules.EventNames{i})
                                    ThisEventName = [InputChannelNames{nChannels} '_' obj.Modules.EventNames{i}{j}];
                                   Assigned = 1;
                                end
                            end
                            if ~Assigned
                                ThisEventName = [InputChannelNames{nChannels} '_' num2str(j)]; 
                            end
                            EventNames{Pos} = ThisEventName; Pos = Pos + 1;
                        end
                    case 'X'
                        if nUSB == 0
                            obj.HW.Pos.Event_USB = Pos;
                        end
                        nChannels = nChannels + 1; nUSB = nUSB + 1;
                        InputChannelNames{nChannels} = ['USB' num2str(i)];
                        for j = 1:obj.HW.n.SoftCodes;
                            EventNames{Pos} = ['SoftCode' num2str(j)]; Pos = Pos + 1;
                        end
                        if Pos < obj.HW.n.MaxSerialEvents
                            for j = obj.HW.n.SoftCodes+1:obj.HW.n.SoftCodes+(obj.HW.n.MaxSerialEvents-Pos)+1
                               EventNames{Pos} = ['SoftCode' num2str(j)]; Pos = Pos + 1; 
                            end
                        end
                    case 'P'
                        if nPorts == 0
                            obj.HW.Pos.Event_Port = Pos;
                        end
                        nPorts = nPorts + 1; nChannels = nChannels + 1;
                        InputChannelNames{nChannels} = ['Port' num2str(nPorts)];
                        EventNames{Pos} = [InputChannelNames{nChannels} 'In']; Pos = Pos + 1;
                        EventNames{Pos} = [InputChannelNames{nChannels} 'Out']; Pos = Pos + 1;
                    case 'B'
                        if nBNCs == 0
                            obj.HW.Pos.Event_BNC = Pos;
                        end
                        nBNCs = nBNCs + 1; nChannels = nChannels + 1;
                        InputChannelNames{nChannels} = ['BNC' num2str(nBNCs)];
                        EventNames{Pos} = [InputChannelNames{nChannels} 'High']; Pos = Pos + 1;
                        EventNames{Pos} = [InputChannelNames{nChannels} 'Low']; Pos = Pos + 1;
                    case 'W'
                        if nWires == 0
                            obj.HW.Pos.Event_Wire = Pos;
                        end
                        nWires = nWires + 1; nChannels = nChannels + 1;
                        InputChannelNames{nChannels} = ['Wire' num2str(nWires)];
                        EventNames{Pos} = [InputChannelNames{nChannels} 'High']; Pos = Pos + 1;
                        EventNames{Pos} = [InputChannelNames{nChannels} 'Low']; Pos = Pos + 1;
                end
            end
            for i = 1:obj.HW.n.GlobalTimers
                EventNames{Pos} = ['GlobalTimer' num2str(i) '_Start']; Pos = Pos + 1;
            end
            for i = 1:obj.HW.n.GlobalTimers
                EventNames{Pos} = ['GlobalTimer' num2str(i) '_End']; Pos = Pos + 1;
            end
            for i = 1:obj.HW.n.GlobalCounters
                EventNames{Pos} = ['GlobalCounter' num2str(i) '_End']; Pos = Pos + 1;
            end
            for i = 1:obj.HW.n.Conditions
                EventNames{Pos} = ['Condition' num2str(i)]; Pos = Pos + 1;
            end
            for i = 1:obj.HW.n.UartSerialChannels
                EventNames{Pos} = ['Serial' num2str(i) 'Jump']; Pos = Pos + 1;
            end
            EventNames{Pos} = 'SoftJump'; Pos = Pos + 1;
            EventNames{Pos} = 'Tup';
            obj.StateMachineInfo.EventNames = EventNames;
            obj.StateMachineInfo.InputChannelNames = InputChannelNames;
            obj.HW.StateTimerPosition = Pos;
            
            obj.HW.IOEventStartposition = find(obj.HW.EventTypes == 'I', 1);
            obj.HW.GlobalTimerStartposition = find(obj.HW.EventTypes == 'T', 1);
            obj.HW.GlobalCounterStartposition = find(obj.HW.EventTypes == '+', 1);
            obj.HW.ConditionStartposition = find(obj.HW.EventTypes == 'C', 1);
            obj.HW.StateTimerPosition = find(obj.HW.EventTypes == 'U');
            
            OutputChannelNames = cell(1,obj.HW.n.Outputs + 3);
            Pos = 0;
            nUSB = 0;
            nSPI = 0;
            nBNCs = 0;
            nWires = 0;
            nPorts = 0;
            for i = 1:obj.HW.n.Outputs
                Pos = Pos + 1;
                switch obj.HW.Outputs(i)
                    case 'U'
                        if obj.Modules.Connected(i)
                            OutputChannelNames{Pos} = obj.Modules.Name{i};
                        else
                            OutputChannelNames{Pos} = ['Serial' num2str(i)];
                            obj.Modules.Name{i} = OutputChannelNames{Pos};
                        end
                    case 'X'
                        OutputChannelNames{Pos} = 'SoftCode';
                        if nUSB == 0
                            obj.HW.Pos.Output_USB = Pos;
                            nUSB = 1;
                        end
                    case 'S'
                        if nSPI == 0
                            obj.HW.Pos.Output_SPI = Pos;
                            nSPI = nSPI + 1;
                        end
                        OutputChannelNames{Pos} = 'ValveState'; % Assumes SPI valve shift register
                    case 'P'
                        if nPorts == 0
                            obj.HW.Pos.Output_PWM = Pos;
                        end
                        nPorts = nPorts + 1;
                        OutputChannelNames{Pos} = ['PWM' num2str(nPorts)];
                    case 'B'
                        if nBNCs == 0
                            obj.HW.Pos.Output_BNC = Pos;
                        end
                        nBNCs = nBNCs + 1;
                        OutputChannelNames{Pos} = ['BNC' num2str(nBNCs)];
                    case 'W'
                        if nWires == 0
                            obj.HW.Pos.Output_Wire = Pos;
                        end
                        nWires = nWires + 1;
                        OutputChannelNames{Pos} = ['Wire' num2str(nWires)];
                end
            end
            Pos = Pos + 1;
            OutputChannelNames{Pos} = 'GlobalTimerTrig';
            obj.HW.Pos.GlobalTimerTrig = Pos;
            Pos = Pos + 1;
            OutputChannelNames{Pos} = 'GlobalTimerCancel';
            obj.HW.Pos.GlobalTimerCancel = Pos;
            Pos = Pos + 1;
            OutputChannelNames{Pos} = 'GlobalCounterReset';
            obj.HW.Pos.GlobalCounterReset = Pos;
            obj.StateMachineInfo.OutputChannelNames = OutputChannelNames;
            obj.StateMachineInfo.nEvents = length(obj.StateMachineInfo.EventNames);
            obj.StateMachineInfo.nOutputChannels = length(obj.StateMachineInfo.OutputChannelNames);
            % Create blank state matrix to store in Bpod object
            sma.meta = struct;
            sma.nStates = 0;
            sma.nStatesInManifest = 0;
            sma.Manifest = cell(1,obj.StateMachineInfo.MaxStates); % State names in the order they were added by user
            sma.StateNames = {'Placeholder'}; % State names in the order they were referenced
            nExtraEvents = obj.HW.n.GlobalTimers*2 + obj.HW.n.GlobalCounters + obj.HW.n.Conditions;
            sma.meta.InputMatrixSize = obj.StateMachineInfo.nEvents-(nExtraEvents+obj.HW.n.SerialChannels+1); % Subtract Global timers/counters/conditions, jump states and tup
            sma.InputMatrix = ones(1,sma.meta.InputMatrixSize);
            sma.meta.OutputMatrixSize = obj.StateMachineInfo.nOutputChannels;
            sma.OutputMatrix = zeros(1,sma.meta.OutputMatrixSize);
            sma.StateTimerMatrix = zeros(1,1);
            sma.GlobalTimerStartMatrix = ones(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimerEndMatrix = ones(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers = struct;
            sma.GlobalTimers.Duration = zeros(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers.OnsetDelay = zeros(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers.OutputChannel = ones(1,obj.HW.n.GlobalTimers)*255; % Default channel code of 255 is "no channel".
            sma.GlobalTimers.OnMessage = zeros(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers.OffMessage = zeros(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers.LoopInterval = zeros(1,obj.HW.n.GlobalTimers);
            sma.GlobalTimers.LoopMode = zeros(1,obj.HW.n.GlobalTimers); % Set to 1 if timer loops until canceled or trial-end
            sma.GlobalTimers.SendEvents = ones(1,obj.HW.n.GlobalTimers); % Set to 0 to disable global timer events (if looping at high freq)
            sma.GlobalTimers.IsSet = zeros(1,obj.HW.n.GlobalTimers); % Changed to 1 when the timer is set with SetGlobalTimer
            sma.GlobalCounterMatrix = ones(1,obj.HW.n.GlobalCounters);
            sma.GlobalCounterEvents = ones(1,obj.HW.n.GlobalCounters)*255; % Default event of 255 is code for "no event attached".
            sma.GlobalCounterThresholds = zeros(1,obj.HW.n.GlobalCounters);
            sma.GlobalCounterSet = zeros(1,obj.HW.n.GlobalCounters); % Changed to 1 when the counter event is identified and given a threshold with SetGlobalCounter
            sma.ConditionMatrix = zeros(1,obj.HW.n.Conditions);
            sma.ConditionChannels = zeros(1,obj.HW.n.Conditions);
            sma.ConditionValues = zeros(1,obj.HW.n.Conditions);
            sma.ConditionSet = zeros(1,obj.HW.n.Conditions);
            sma.StateTimers = 0;
            sma.StatesDefined = 1; % Referenced states are set to 0. Defined states are set to 1. Both occur with AddState
            obj.BlankStateMachine = sma;
        end
        function obj = InitializeGUI(obj)
            TitleFontName = 'OCRASTD';
            FontName = 'OCRASTD';
            % Add labels
            LabelFontColor = [0.8 0.8 0.8];
            if 1 %obj.EmulatorMode == 0
                Title = 'Bpod Console';
                TitleColor = LabelFontColor;
            else
                Title = 'Bpod Emulator';
                TitleColor = [0.9 0 0];
            end
            if ispc
                Vvsm = 10; Vsm = 10; Sm = 12; Med = 13; Lg = 20;
            elseif ismac
                Vvsm = 12; Vsm = 14; Sm = 16; Med = 17; Lg = 22;
                FontName = 'Arial';
            else
                Vvsm = 10; Vsm = 10; Sm = 12; Med = 13; Lg = 20;
            end
            
            obj.GUIHandles.MainFig = figure('Position',[80 100 825 400],'name','Bpod Console','numbertitle','off',...
                'MenuBar', 'none', 'Resize', 'off', 'CloseRequestFcn', 'EndBpod');
            obj.GUIHandles.Console = axes('units','normalized', 'position',[0 0 1 1]);
            uistack(obj.GUIHandles.Console,'bottom');
            BG = imread('ConsoleBG3.bmp');
            image(BG); axis off;
            
            obj.GUIData.GoButton = imread('PlayButton.bmp');
            obj.GUIData.PauseButton = imread('PauseButton.bmp');
            obj.GUIData.PauseRequestedButton = imread('PauseRequestedButton.bmp');
            obj.GUIData.StopButton = imread('StopButton.bmp');
            obj.GUIHandles.RunButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [742 100 60 60], 'Callback', 'RunProtocol(''StartPause'')', 'CData', obj.GUIData.GoButton, 'TooltipString', 'Launch behavior session');
            obj.GUIHandles.EndButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [742 20 60 60], 'Callback', 'RunProtocol(''Stop'')', 'CData', obj.GUIData.StopButton, 'TooltipString', 'End session');
            
            obj.GUIData.OffButton = imread('ButtonOff.bmp');
            obj.GUIData.OffButtonDark = imread('ButtonOff_dark.bmp');
            obj.GUIData.OnButton = imread('ButtonOn.bmp');
            obj.GUIData.OnButtonDark = imread('ButtonOn_dark.bmp');
            obj.GUIData.SettingsButton = imread('SettingsButton.bmp');
            obj.GUIData.RefreshButton = imread('RefreshButton.bmp');
            obj.GUIData.USBButton = imread('USBButton.bmp');
            obj.GUIData.SystemInfoButton = imread('SystemInfoButton.bmp');
            obj.GUIData.DocButton = imread('DocButton.bmp');
            obj.GUIData.AddProtocolButton = imread('AddProtocolIcon.bmp');
            obj.GUIHandles.SettingsButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [778 275 29 29], 'Callback', 'BpodSettingsMenu', 'CData', obj.GUIData.SettingsButton, 'TooltipString', 'Settings and calibration');
            obj.GUIHandles.RefreshButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [733 275 29 29], 'Callback', @(h,e)obj.LoadModules(), 'CData', obj.GUIData.RefreshButton, 'TooltipString', 'Refresh modules');
            obj.GUIHandles.SystemInfoButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [778 227 29 29], 'Callback', 'BpodSystemInfo', 'CData', obj.GUIData.SystemInfoButton, 'TooltipString', 'View system info');
            obj.GUIHandles.USBButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [733 227 29 29], 'Callback', 'ConfigureModuleUSB', 'CData', obj.GUIData.USBButton, 'TooltipString', 'Configure module USB ports');
            obj.GUIHandles.DocButton = uicontrol('Style', 'pushbutton', 'String', '', 'Position', [796 371 29 29], 'Callback', @(h,e)obj.Wiki(), 'CData', obj.GUIData.DocButton, 'TooltipString', 'Documentation wiki');
            if ispc
                CfgXpos = 735; Movpos = 335; Sesspos = 731;
            elseif ismac
                CfgXpos = 745; Movpos = 360; Sesspos = 741;
            else
                CfgXpos = 735; Movpos = 335; Sesspos = 731;
            end
            text(CfgXpos, 65,'Config', 'FontName', FontName, 'FontSize', Med, 'Color', LabelFontColor);
            line([730 815], [79 79], 'Color', LabelFontColor, 'LineWidth', 2);
            text(Movpos, 65,'Manual Override', 'FontName', FontName, 'FontSize', Med, 'Color', LabelFontColor);
            line([145 718], [79 79], 'Color', LabelFontColor, 'LineWidth', 2);
            text(Sesspos, 205,'Session', 'FontName', FontName, 'FontSize', Med, 'Color', LabelFontColor);
            line([730 815], [220 220], 'Color', LabelFontColor, 'LineWidth', 2);
            
            PluginPanelWidth = 575;
            PluginPanelOffset = 145;
            TabWidth = (PluginPanelWidth)/obj.HW.n.SerialChannels;
            obj.GUIHandles.PanelButton = zeros(1,obj.HW.n.SerialChannels);
            ModuleNames = {'<html>&nbsp;State<br>Machine', 'Serial 1', 'Serial 2', 'Serial 3', 'Serial 4', 'Serial 5'};
            FormattedModuleNames = ModuleNames;
            TabPos = PluginPanelOffset;
            obj.GUIData.DefaultPanel = ones(1,obj.HW.n.SerialChannels);
            for i = 1:obj.HW.n.SerialChannels
                % Set module names
                if i > 1
                    if obj.Modules.Connected(i-1)
                        ThisModuleName = obj.Modules.Name{i-1};
                        UCase = (ThisModuleName > 64 & ThisModuleName < 91);
                        LCase = (ThisModuleName > 96 & ThisModuleName < 123);
                        if sum(UCase) == 2 && length(UCase) > 3 && sum(LCase) > 0
                            CapPos = find(UCase);
                            NamePart1 = ThisModuleName(1:CapPos(2)-1);
                            NamePart2 = ThisModuleName(CapPos(2):end);
                            BufferLength = 5-length(NamePart2);
                            if BufferLength < 1
                                BufferLength = 0;
                            end
                            Buffer = ['<html>' repmat('&nbsp;', 1, BufferLength)];
                            NamePart2 = [Buffer NamePart2(1:end-1) ' ' NamePart2(end)];
                            FormattedModuleNames{i} = ['<html>&nbsp;' NamePart1 '<br>' NamePart2];
                        else
                            ThisModuleName = [ThisModuleName(1:end-1) ' ' ThisModuleName(end)];
                            FormattedModuleNames{i} = ThisModuleName;
                        end
                    else
                        ThisModuleName = 'None';
                    end
                end
                % Draw tab
                obj.GUIHandles.PanelButton(i) = uicontrol('Style', 'pushbutton', 'String', FormattedModuleNames{i}, 'Callback', @(h,e)obj.SwitchPanels(i), 'BackgroundColor', [0.37 0.37 0.37], 'Position', [TabPos 272 TabWidth-1 49], 'ForegroundColor', [0.9 0.9 0.9], 'FontSize', Vvsm, 'FontName', 'OCR A STD');
                TabPos = TabPos + TabWidth;
                if isempty(strfind(obj.HostOS, 'Linux'))
                    jButton = findjobj(obj.GUIHandles.PanelButton(i));
                    jButton.setBorderPainted(false);
                end
                % Draw panel
                obj.GUIHandles.OverridePanel(i) = uipanel(obj.GUIHandles.MainFig, 'Units', 'Pixels', 'Position',[PluginPanelOffset,16,PluginPanelWidth,256],...
                    'FontSize',12, 'BackgroundColor',[.38 .38 .38],...
                    'HighlightColor', [0.4 0.4 0.4]);
                
                % Draw Axes
                obj.GUIHandles.OverridePanelAxes(i) = axes('Parent', obj.GUIHandles.OverridePanel(i), 'Position',[0 0 1 1], 'Color',[.37,.37,.37], 'Xlim', [0 PluginPanelWidth], 'Ylim', [0 250], 'UserData', 'PrimaryPanelAxes'); axis off;
                uistack(obj.GUIHandles.OverridePanel(1),'top');
                if i == 1 % State machine panel
                    switch obj.MachineType
                        case 1
                            StateMachinePanel_0_5; % This is a file in /Bpod/Functions/OverridePanels/
                        case 2
                            StateMachinePanel_0_7;
                        case 3
                            StateMachinePanel_PSM_0_1;
                    end
                else % Module panel
                    % Find module panel function and draw panel, otherwise draw default panel
                    if ~strcmp(ThisModuleName, 'None')
                        ModuleTypeString = ThisModuleName(1:end-1);
                        ModuleFileName = [ModuleTypeString '_Panel.m'];
                        if exist(ModuleFileName, 'file')
                            ModuleFunctionName = [ModuleTypeString '_Panel'];
                            eval([ModuleFunctionName '(obj.GUIHandles.OverridePanel(' num2str(i) '), ''' ThisModuleName ''');']);
                            obj.GUIData.DefaultPanel(i) = 0;
                        else % No override panel function exists for module
                            DefaultBpodModule_Panel(obj.GUIHandles.OverridePanel(i), obj.Modules.Name{i-1});
                        end
                        
                    else % Module did not respond
                        DefaultBpodModule_Panel(obj.GUIHandles.OverridePanel(i), obj.Modules.Name{i-1});
                    end
                end
                drawnow;
                set(obj.GUIHandles.OverridePanel(i), 'Visible', 'off');
            end
            set (obj.GUIHandles.PanelButton(1), 'BackgroundColor', [0.45 0.45 0.45]); % Set first button active
            set(obj.GUIHandles.OverridePanel(1), 'Visible', 'on');
            obj.GUIData.CurrentPanel = 1;
            axes(obj.GUIHandles.Console);
            uistack(obj.GUIHandles.Console,'bottom');

            if isempty(strfind(obj.HostOS, 'Linux'))
                % Draw lines between tabs
                TabPos = PluginPanelOffset;
                for i = 1:obj.HW.n.SerialChannels-1
                    TabPos = TabPos + TabWidth;
                    line([TabPos-1 TabPos-1], [82 130], 'Color', [0.45 0.45 0.45], 'LineWidth', 5);
                end
                if isempty(strfind(obj.HostOS, 'Linux'))
                    for i = 1:obj.HW.n.SerialChannels
                        jButton = findjobj(obj.GUIHandles.PanelButton(i));
                        jButton.setBorderPainted(false);
                    end
                end
            end
            if ispc
                InfoDispFontSize = 9; InfoDispBoxHeight = 20; InfoDispBoxWidth = 115; Ypos = 268;
            elseif ismac
                InfoDispFontSize = 12; InfoDispBoxHeight = 22; InfoDispBoxWidth = 115; Ypos = 264;
            else
                InfoDispFontSize = 7.5; InfoDispBoxHeight = 23; InfoDispBoxWidth = 120; Ypos = 268;
            end
            
            obj.GUIHandles.CurrentStateDisplay = uicontrol('Style', 'text', 'String', 'None', 'Position', [12 Ypos InfoDispBoxWidth InfoDispBoxHeight], 'FontWeight', 'bold', 'FontSize', InfoDispFontSize); Ypos = Ypos - 51;
            obj.GUIHandles.PreviousStateDisplay = uicontrol('Style', 'text', 'String', 'None', 'Position', [12 Ypos InfoDispBoxWidth InfoDispBoxHeight], 'FontWeight', 'bold', 'FontSize', InfoDispFontSize); Ypos = Ypos - 51;
            obj.GUIHandles.LastEventDisplay = uicontrol('Style', 'text', 'String', 'None', 'Position', [12 Ypos InfoDispBoxWidth InfoDispBoxHeight], 'FontWeight', 'bold', 'FontSize', InfoDispFontSize); Ypos = Ypos - 51;
            obj.GUIHandles.TimeDisplay = uicontrol('Style', 'text', 'String', '0', 'Position', [12 Ypos InfoDispBoxWidth InfoDispBoxHeight], 'FontWeight', 'bold', 'FontSize', InfoDispFontSize); Ypos = Ypos - 51;
            obj.GUIHandles.CxnDisplay = uicontrol('Style', 'text', 'String', 'Idle', 'Position', [12 Ypos InfoDispBoxWidth InfoDispBoxHeight], 'FontWeight', 'bold', 'FontSize', InfoDispFontSize); 
            obj.FixPushbuttons;
            text(15, 30, Title, 'FontName', TitleFontName, 'FontSize', Lg, 'Color', TitleColor);
            line([280 770], [30 30], 'Color', LabelFontColor, 'LineWidth', 4);
            
            text(10, 102,'Current State', 'FontName', FontName, 'FontSize', Vsm, 'Color', LabelFontColor);
            text(10, 153,'Previous State', 'FontName', FontName, 'FontSize', Vsm, 'Color', LabelFontColor);
            text(10, 204,'Last Event', 'FontName', FontName, 'FontSize', Vsm, 'Color', LabelFontColor);
            text(10, 255,'Trial-Start', 'FontName', FontName, 'FontSize', Vsm, 'Color', LabelFontColor);
            text(10, 306,'Link Status', 'FontName', FontName, 'FontSize', Vsm, 'Color', LabelFontColor);
            text(15, 65,'Live Info', 'FontName', FontName, 'FontSize', Med, 'Color', LabelFontColor);
            line([10 130], [79 79], 'Color', LabelFontColor, 'LineWidth', 2);
        end
        function obj = refreshGUIPanels(obj)
            if obj.Status.BeingUsed == 0
                ModuleNames = {'<html>&nbsp;State<br>Machine', 'Serial 1', 'Serial 2', 'Serial 3', 'Serial 4', 'Serial 5'};
                FormattedModuleNames = ModuleNames;
                obj.GUIData.DefaultPanel = ones(1,obj.HW.n.SerialChannels);
                for i = 2:obj.HW.n.SerialChannels
                    if obj.Modules.Connected(i-1)
                        ThisModuleName = obj.Modules.Name{i-1};
                        UCase = (ThisModuleName > 64 & ThisModuleName < 91);
                        if sum(UCase) == 2 && length(UCase) > 3
                            CapPos = find(UCase);
                            NamePart1 = ThisModuleName(1:CapPos(2)-1);
                            NamePart2 = ThisModuleName(CapPos(2):end);
                            BufferLength = 5-length(NamePart2);
                            if BufferLength < 1
                                BufferLength = 0;
                            end
                            Buffer = ['<html>' repmat('&nbsp;', 1, BufferLength)];
                            NamePart2 = [Buffer NamePart2(1:end-1) ' ' NamePart2(end)];
                            FormattedModuleNames{i} = ['<html>&nbsp;' NamePart1 '<br>' NamePart2];
                        else
                            ThisModuleName = [ThisModuleName(1:end-1) ' ' ThisModuleName(end)];
                            FormattedModuleNames{i} = ThisModuleName;
                        end
                    else
                        ThisModuleName = 'None';
                    end
                    % Update tab
                    set(obj.GUIHandles.PanelButton(i), 'String', FormattedModuleNames{i});
                    % Clear panel contents
                    set(obj.GUIHandles.OverridePanel(i), 'Visible', 'on');
                    uistack(obj.GUIHandles.OverridePanel(i),'top');
                    axes(obj.GUIHandles.OverridePanelAxes(i)); % Make correct panel axes the current axes
                    PanelChildren = get(obj.GUIHandles.OverridePanel(i), 'Children');
                    nChildren = length(PanelChildren);
                    for j = 1:nChildren
                        DeleteIt = 1;
                        UD = get(PanelChildren(j), 'UserData');
                        if ischar(UD)
                            if strcmp(UD, 'PrimaryPanelAxes')
                                DeleteIt = 0;
                                AxisChildren = get(PanelChildren(j), 'Children');
                                nAxisChildren = length(AxisChildren);
                                for k = 1:nAxisChildren
                                    delete(AxisChildren(k));
                                end
                            end
                        end
                        if DeleteIt
                            delete(PanelChildren(j));
                        end
                    end
                    % Find module panel function and draw panel, otherwise draw default panel
                    if ~strcmp(ThisModuleName, 'None')
                        ModuleTypeString = ThisModuleName(1:end-1);
                        ModuleFileName = [ModuleTypeString '_Panel.m'];
                        if exist(ModuleFileName, 'file')
                            ModuleFunctionName = [ModuleTypeString '_Panel'];
                            eval([ModuleFunctionName '(obj.GUIHandles.OverridePanel(' num2str(i) '), ''' ThisModuleName ''');']);
                            obj.GUIData.DefaultPanel(i) = 0;
                        else % No override panel function exists for module
                            DefaultBpodModule_Panel(obj.GUIHandles.OverridePanel(i), obj.Modules.Name{i-1});
                        end
                        
                    else % Module did not respond
                        DefaultBpodModule_Panel(obj.GUIHandles.OverridePanel(i), obj.Modules.Name{i-1});
                    end
                    set(obj.GUIHandles.OverridePanel(i), 'Visible', 'off');
                end
                for i = 2:obj.HW.n.SerialChannels
                    set(obj.GUIHandles.PanelButton(i), 'BackgroundColor', [0.37 0.37 0.37]);
                end
                set (obj.GUIHandles.PanelButton(1), 'BackgroundColor', [0.45 0.45 0.45]); % Set first button active
                set(obj.GUIHandles.OverridePanel(1), 'Visible', 'on');
                uistack(obj.GUIHandles.OverridePanel(1),'top');
                axes(obj.GUIHandles.Console);
                uistack(obj.GUIHandles.Console,'bottom');
                if isempty(strfind(obj.HostOS, 'Linux'))
                    for i = 1:obj.HW.n.SerialChannels
                        jButton = findjobj(obj.GUIHandles.PanelButton(i));
                        jButton.setBorderPainted(false);
                    end
                end
            end
        end
        function obj = RefreshGUI(obj)
            if ~isempty(obj.StateMatrix)
                set(obj.GUIHandles.PreviousStateDisplay, 'String', obj.Status.LastStateName);
                set(obj.GUIHandles.CurrentStateDisplay, 'String', obj.Status.CurrentStateName);
                if obj.Status.LastEvent > 0
                    if obj.Status.LastEvent <= length(obj.StateMachineInfo.EventNames)
                        set(obj.GUIHandles.LastEventDisplay, 'String', obj.StateMachineInfo.EventNames{obj.Status.LastEvent});
                    end
                end
            end
            startPos = obj.HW.n.SerialChannels;
            ChangedOutputChannels = find(obj.HardwareState.OutputState ~= obj.LastHardwareState.OutputState);
            ChangedOutputChannels = ChangedOutputChannels(ChangedOutputChannels>startPos);
            for i = ChangedOutputChannels
                thisChannelType = obj.HardwareState.OutputType(i);
                thisChannelState = obj.HardwareState.OutputState(i);
                lastChannelState = obj.LastHardwareState.OutputState(i);
                switch thisChannelType
                    case 'S' % Assume this SPI channel is a power shift register to control valves
                        for j = 1:8
                            valveState = bitget(thisChannelState,j);
                            lastValveState = bitget(lastChannelState, j);
                            if valveState ~= lastValveState
                                if obj.GUIData.CurrentPanel == 1
                                    if valveState == 1
                                        set(obj.GUIHandles.PortValveButton(j), 'CData', obj.GUIData.OnButtonDark);
                                    else
                                        set(obj.GUIHandles.PortValveButton(j), 'CData', obj.GUIData.OffButtonDark);
                                    end
                                end
                            end
                        end
                    case 'B' % BNC (digital)
                        if obj.GUIData.CurrentPanel == 1
                            if thisChannelState == 1
                                set(obj.GUIHandles.BNCOutputButton(i-obj.HW.Pos.Output_BNC+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.BNCOutputButton(i-obj.HW.Pos.Output_BNC+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                        end
                    case 'W' % Wire (digital)
                        if obj.GUIData.CurrentPanel == 1
                            if thisChannelState == 1
                                set(obj.GUIHandles.WireOutputButton(i-obj.HW.Pos.Output_Wire+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.WireOutputButton(i-obj.HW.Pos.Output_Wire+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                        end
                    case 'P' % Port (PWM)
                        if obj.GUIData.CurrentPanel == 1
                            if thisChannelState > 0
                                set(obj.GUIHandles.PortLEDButton(i-obj.HW.Pos.Output_PWM+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.PortLEDButton(i-obj.HW.Pos.Output_PWM+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                        end
                end
            end
            ChangedInputChannels = find(obj.HardwareState.InputState ~= obj.LastHardwareState.InputState);
            for i = ChangedInputChannels
                thisChannelType = obj.HardwareState.InputType(i);
                thisChannelState = obj.HardwareState.InputState(i);
                if obj.GUIData.CurrentPanel == 1
                    switch thisChannelType
                        case 'P' % Port (digital)
                            if thisChannelState == 1
                                set(obj.GUIHandles.PortvPokeButton(i-obj.HW.Pos.Input_Port+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.PortvPokeButton(i-obj.HW.Pos.Input_Port+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                        case 'B' % BNC (digital)
                            if thisChannelState == 1
                                set(obj.GUIHandles.BNCInputButton(i-obj.HW.Pos.Input_BNC+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.BNCInputButton(i-obj.HW.Pos.Input_BNC+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                        case 'W' % Wire (digital)
                            if thisChannelState == 1
                                set(obj.GUIHandles.WireInputButton(i-obj.HW.Pos.Input_Wire+1), 'CData', obj.GUIData.OnButtonDark);
                            else
                                set(obj.GUIHandles.WireInputButton(i-obj.HW.Pos.Input_Wire+1), 'CData', obj.GUIData.OffButtonDark);
                            end
                    end
                end
            end
            obj.LastHardwareState = obj.HardwareState;
        end
        function obj = setupFolders(obj)
            if ispc
                FigHeight = 130; Label1Ypos = 28; Label2Ypos = 68;
            else
                FigHeight = 150; Label1Ypos = 38; Label2Ypos = 75;
            end
            obj.GUIHandles.FolderConfigFig = figure('Position', [350 480 600 FigHeight],'name','Setup folders','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off');
            ha = axes('units','normalized', 'position',[0 0 1 1]);
            uistack(ha,'bottom');
            BG = imread('SettingsMenuBG2.bmp');
            imagesc(BG); axis off; drawnow;
            text(10, Label1Ypos,'Protocols','Parent', ha , 'FontName', 'OCRAStd', 'FontSize', 13, 'Color', [0.8 0.8 0.8]);
            text(10, Label2Ypos,'Data Root','Parent', ha , 'FontName', 'OCRAStd', 'FontSize', 13, 'Color', [0.8 0.8 0.8]);
            if isfield(obj.SystemSettings, 'ProtocolFolder')
                if isempty(obj.SystemSettings.ProtocolFolder)
                    ProtocolPath = fullfile(obj.Path.LocalDir, 'Protocols',filesep);
                else
                    ProtocolPath = obj.SystemSettings.ProtocolFolder;
                end
            else
                ProtocolPath = fullfile(obj.Path.LocalDir, 'Protocols',filesep);
            end
            if isfield(obj.SystemSettings, 'DataFolder')
                if isempty(obj.SystemSettings.DataFolder)
                    DataPath = fullfile(obj.Path.LocalDir, 'Data',filesep);
                else
                    DataPath = obj.SystemSettings.DataFolder;
                end
            else
                DataPath = fullfile(obj.Path.LocalDir, 'Data',filesep);
            end
            ImportButtonGFX = imread('ImportButton.bmp');
            obj.GUIHandles.setupFoldersButton = uicontrol(obj.GUIHandles.FolderConfigFig, 'Style', 'pushbutton', 'String', 'Ok', 'Position', [270 10 60 25], 'Callback', @(h,e)obj.setFolders(), 'BackgroundColor', [.4 .4 .4], 'ForegroundColor', [1 1 1]);
            obj.GUIHandles.dataFolderEdit = uicontrol(obj.GUIHandles.FolderConfigFig, 'Style', 'edit', 'String', DataPath, 'Position', [140 50 410 25], 'HorizontalAlignment', 'Left', 'BackgroundColor', [.8 .8 .8], 'FontSize', 10, 'FontName', 'Arial');
            obj.GUIHandles.dataFolderNav = uicontrol(obj.GUIHandles.FolderConfigFig, 'Style', 'pushbutton', 'String', '', 'Position', [560 50 25 25], 'BackgroundColor', [.8 .8 .8], 'CData', ImportButtonGFX, 'Callback', @(h,e)obj.folderSetupUIGet('Data'));
            obj.GUIHandles.protocolFolderEdit = uicontrol(obj.GUIHandles.FolderConfigFig, 'Style', 'edit', 'String', ProtocolPath, 'Position', [140 90 410 25], 'HorizontalAlignment', 'Left', 'BackgroundColor', [.8 .8 .8], 'FontSize', 10, 'FontName', 'Arial');
            obj.GUIHandles.protocolFolderNav = uicontrol(obj.GUIHandles.FolderConfigFig, 'Style', 'pushbutton', 'String', '', 'Position', [560 90 25 25], 'BackgroundColor', [.8 .8 .8], 'CData', ImportButtonGFX, 'Callback', @(h,e)obj.folderSetupUIGet('Protocol'));
        end
        function obj = folderSetupUIGet(obj, type)
            switch type
                case 'Data'
                    OriginalFolder = get(obj.GUIHandles.dataFolderEdit, 'String');
                    ChosenFolder = uigetdir(obj.Path.LocalDir, 'Select Bpod data folder');
                    if ChosenFolder == 0
                        ChosenFolder = OriginalFolder;
                    end
                    set(obj.GUIHandles.dataFolderEdit, 'String', fullfile(ChosenFolder, filesep));
                case 'Protocol'
                    OriginalFolder = get(obj.GUIHandles.protocolFolderEdit, 'String');
                    ChosenFolder = uigetdir(obj.Path.LocalDir, 'Select Bpod protocol folder');
                    if ChosenFolder == 0
                        ChosenFolder = OriginalFolder;
                    end
                    set(obj.GUIHandles.protocolFolderEdit, 'String', fullfile(ChosenFolder, filesep));
            end
        end
        function obj = setFolders(obj)
            DataFolder = get(obj.GUIHandles.dataFolderEdit, 'String');
            ProtocolFolder = get(obj.GUIHandles.protocolFolderEdit, 'String');
            if exist(DataFolder) == 0
                mkdir(DataFolder);
            end
            if exist(ProtocolFolder) == 0
                mkdir(ProtocolFolder);
            end
            Contents = dir(ProtocolFolder);
            if length(Contents) == 2
                choice = questdlg('Copy example protocols to new protocol folder?', ...
                    'Protocol folder is empty', ...
                    'Yes', 'No', 'No');
                if strcmp(choice, 'Yes')
                    copyfile(fullfile(obj.Path.BpodRoot, 'Examples', 'Protocols'), ProtocolFolder);
                end
            end
            obj.Path.ProtocolFolder = ProtocolFolder;
            obj.Path.DataFolder = DataFolder;
            obj.SystemSettings.ProtocolFolder = ProtocolFolder;
            obj.SystemSettings.DataFolder = DataFolder;
            obj.SaveSettings;
            close(obj.GUIHandles.FolderConfigFig);
        end
        function monitoring(obj,state)
            obj.SerialPort.write(['Q' state], 'uint8');
            switch(state)
                case 0
                    disp('Cycle monitoring OFF.');
                case 1
                    disp('Cycle monitoring ON.');
            end
            obj.CycleMonitoring = state;
        end
        function returnMonitorStats(obj)
            if obj.CycleMonitoring
                obj.SerialPort.write('#', 'uint8');
                CallbackRange = obj.SerialPort.read(2, 'uint16');
                disp(['Minimum cycle duration measured: ' num2str(CallbackRange(1)) 'us']);
                disp(['Maximum cycle duration measured: ' num2str(CallbackRange(2)) 'us']);
            else
                error('You must first activate cycle monitoring with the function: monitoring(state)')
            end
        end
        function obj = Wiki(obj)
            if ispc || ismac
                web ('https://www.sites.google.com/site/bpoddocumentation/home', '-browser');
            else
                web ('https://www.sites.google.com/site/bpoddocumentation/home');
            end
        end
        function obj = SaveSettings(obj)
            BpodSettings = obj.SystemSettings;
            save(fullfile(obj.Path.LocalDir, 'Settings', 'BpodSettings.mat'), 'BpodSettings');
        end
        function obj = BeingUsed(obj)
            error('Error: "BpodSystem.BeingUsed" is now "BpodSystem.Status.BeingUsed" - Please update your protocol!')
        end
        function StopModuleRelay(obj, varargin) 
            for i = 1:length(obj.Modules.RelayActive)
                obj.SerialPort.write(['J' i 0], 'uint8');
            end
            RunningState = get(obj.Timers.PortRelayTimer, 'Running');
            if strcmp(RunningState, 'on')
                stop(obj.Timers.PortRelayTimer);
                while strcmp(RunningState, 'on')
                    RunningState = get(obj.Timers.PortRelayTimer, 'Running');
                    pause(.001);
                end
            end
            nAvailable = obj.SerialPort.bytesAvailable;
            if nAvailable > 0
                trash = obj.SerialPort.read(nAvailable, 'uint8');
            end
            obj.Modules.RelayActive(1:end) = 0;
        end
        
        function StartModuleRelay(obj, Module)
            if ischar(Module)
                ModuleNum = find(strcmp(Module, obj.Modules.Name));
            end
            if ~isempty(ModuleNum)
                if (ModuleNum <= length(obj.Modules.Connected))
                    if (sum(obj.Modules.RelayActive)) == 0
                        obj.SerialPort.write(['J' ModuleNum-1 1], 'uint8');
                        obj.Modules.RelayActive(ModuleNum) = 1;
                    else
                        error('Error: You must stop the active module relay with StopModuleRelay() before starting another one.')
                    end
                end
            end
        end
        
        function USBSerialPorts = FindUSBSerialPorts(obj)
            SerialPortKeywords = {'Arduino', 'Teensy', 'Sparkfun', 'COM'};
            nKeywords = length(SerialPortKeywords);
            USBSerialPorts = struct;
            if ispc
                for k = 1:nKeywords
                    [Status RawString] = system(['wmic path Win32_SerialPort Where "Caption LIKE ''%' SerialPortKeywords{k} '%''" Get DeviceID']);
                    PortLocations = strfind(RawString, 'COM');
                    nPorts = length(PortLocations);
                    USBSerialPorts.(SerialPortKeywords{k}) = cell(1,100);
                    nPortsAdded = 0;
                    for p = 1:nPorts
                        Clip = RawString(PortLocations(p):PortLocations(p)+6);
                        CandidatePort = Clip(1:find(Clip == 32,1, 'first')-1);
                        if ~strcmp(CandidatePort, 'COM1')
                            if sum(strcmp(CandidatePort, USBSerialPorts.(SerialPortKeywords{k}))) == 0
                                nPortsAdded = nPortsAdded + 1;
                                USBSerialPorts.(SerialPortKeywords{k}){nPortsAdded} = CandidatePort;
                            end
                        end
                    end
                    USBSerialPorts.(SerialPortKeywords{k}) = USBSerialPorts.(SerialPortKeywords{k})(1:nPortsAdded);
                end
            elseif ismac % Contributed by Thiago Gouvea JUN_9_2016
                [trash, RawSerialPortList] = system('ls /dev/cu.usbmodem*');
                string = strtrim(RawSerialPortList);
                PortStringPositions = strfind(string, '/dev/cu.usbmodem');
                StringEnds = find(string == 9);
                nPorts = length(PortStringPositions);
                CandidatePorts = cell(1,nPorts);
                nGoodPorts = 0;
                for x = 1:nPorts
                    if x < nPorts && nPorts > 1
                        CandidatePort = string(PortStringPositions(x):StringEnds(x)-1);
                    elseif x == nPorts
                        CandidatePort = string(PortStringPositions(x):end);
                    end
                    nGoodPorts = nGoodPorts + 1;
                    CandidatePorts{nGoodPorts} = CandidatePort;
                end
                USBSerialPorts.(SerialPortKeywords{1}) = CandidatePorts(1:nGoodPorts);
                if nKeywords > 1
                    for i = 2:nKeywords
                        USBSerialPorts.(SerialPortKeywords{i}) = '';
                    end
                end
            else
                [trash, RawSerialPortList] = system('ls /dev/ttyACM*');
                string = strtrim(RawSerialPortList);
                PortStringPositions = strfind(string, '/dev/ttyACM');
                nPorts = length(PortStringPositions);
                CandidatePorts = cell(1,nPorts);
                nGoodPorts = 0;
                for x = 1:nPorts
                    if PortStringPositions(x)+11 <= length(string)
                        CandidatePort = strtrim(string(PortStringPositions(x):PortStringPositions(x)+11));
                        nGoodPorts = nGoodPorts + 1;
                        CandidatePorts{nGoodPorts} = CandidatePort;
                    end
                end
                USBSerialPorts.(SerialPortKeywords{1}) = CandidatePorts(1:nGoodPorts);
                if nKeywords > 1
                    for i = 2:nKeywords
                        USBSerialPorts.(SerialPortKeywords{i}) = '';
                    end
                end
            end
        end
        
        function delete(obj) % Destructor
            obj.SerialPort = []; % Trigger the ArCOM port's destructor function (closes and releases port)
            stop(obj.Timers.PortRelayTimer);
            delete(obj.Timers.PortRelayTimer);
        end
    end
    methods (Access = private)      
        function SwitchPanels(obj, panel)
            obj.GUIData.CurrentPanel = 0;
            OffPanels = 1:obj.HW.n.SerialChannels;
            OffPanels = OffPanels(OffPanels~=panel);
            set(obj.GUIHandles.OverridePanel(panel), 'Visible', 'on');
            uistack(obj.GUIHandles.OverridePanel(panel), 'top');
            for i = OffPanels
                % Button -> gray
                set(obj.GUIHandles.PanelButton(i), 'BackgroundColor', [0.37 0.37 0.37]);
                set(obj.GUIHandles.OverridePanel(i), 'Visible', 'off');
            end
            set(obj.GUIHandles.PanelButton(panel), 'BackgroundColor', [0.45 0.45 0.45]);
            if isempty(strfind(obj.HostOS, 'Linux')) % Fix buttons if not on linux
                for i = 1:obj.HW.n.SerialChannels
                    jButton = findjobj(obj.GUIHandles.PanelButton(i));
                    jButton.setBorderPainted(false);
                end
            end
            obj.GUIData.CurrentPanel = panel;
            if obj.EmulatorMode == 0
                % Set module byte stream relay to current module
                obj.StopModuleRelay;
                if panel > 1 
                    if obj.Status.BeingUsed == 0 && obj.GUIData.DefaultPanel(panel) == 1
                        obj.SerialPort.write(['J' panel-2 1], 'uint8');
                        obj.Modules.RelayActive(panel-1) = 1;
                        % Start timer to scan port
                        start(obj.Timers.PortRelayTimer);
                    end
                end
            end
            obj.FixPushbuttons;
        end
        
        function FixPushbuttons(obj)
            % Remove all the nasty borders around pushbuttons on platforms besides win7
            if isempty(strfind(obj.HostOS, 'Windows 7'))
                handles = findjobj('class', 'pushbutton');
                set(handles, 'border', []);
            end
        end
        
        function BpodSplashScreen(obj, Stage)
            if Stage == 1
                ha = axes('units','normalized', 'position',[0 0 1 1]);
                uistack(ha,'bottom');
            end
            Img = obj.SplashData.BG;
            Img(201:240,1:485) = obj.SplashData.Messages(:,:,Stage);
            Img(270:274, 43:442) = ones(5,400)*128;
            StartPos = 43;
            EndPos = 44;
            switch Stage
                case 1
                    StepSize = 3;
                    while EndPos < 123
                        EndPos = EndPos + StepSize;
                        Img(270:274, StartPos:EndPos) = ones(5,(EndPos-(StartPos-1)))*20;
                        imagesc(Img); colormap('gray'); set(gcf,'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); axis off; drawnow;
                    end
                case 2
                    StepSize = 5;
                    EndPos = 123;
                    while EndPos < 203
                        EndPos = EndPos + StepSize;
                        Img(270:274, StartPos:EndPos) = ones(5,(EndPos-(StartPos-1)))*20;
                        imagesc(Img); colormap('gray'); set(gcf,'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); axis off; drawnow;
                    end
                case 3
                    StepSize = 5;
                    EndPos = 203;
                    while EndPos < 283
                        EndPos = EndPos + StepSize;
                        Img(270:274, StartPos:EndPos) = ones(5,(EndPos-(StartPos-1)))*20;
                        imagesc(Img); colormap('gray'); set(gcf,'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); axis off; drawnow;
                    end
                case 4
                    StepSize = 5;
                    EndPos = 283;
                    while EndPos < 363
                        EndPos = EndPos + StepSize;
                        Img(270:274, StartPos:EndPos) = ones(5,(EndPos-(StartPos-1)))*20;
                        imagesc(Img); colormap('gray'); set(gcf,'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); axis off; drawnow;
                    end
                case 5
                    StepSize = 5;
                    EndPos = 363;
                    while EndPos < 442
                        EndPos = EndPos + StepSize;
                        Img(270:274, StartPos:EndPos) = ones(5,(EndPos-(StartPos-1)))*20;
                        imagesc(Img); colormap('gray'); set(gcf,'name','Bpod','numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); axis off; drawnow;
                    end
                    pause(.5);
            end
        end
    end
end